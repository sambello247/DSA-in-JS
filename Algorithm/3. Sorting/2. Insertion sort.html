<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="../../css/style.css">
    <title>Insertion Sort</title>
</head>
<body>
    <h2>Insertion Sort</h2>
    <p>Insertion sort is a simple sorting algorithm that builds the final sorted array one item at a time. It works by repeatedly inserting an element from the unsorted portion of the array into its correct position in the sorted portion of the array.</p>

    <p>The basic idea behind insertion sort is to divide the array into two parts: a sorted subarray and an unsorted subarray. Initially, the sorted subarray contains only the first element of the array, and the unsorted subarray contains the remaining elements. The algorithm then iterates over the unsorted subarray, taking one element at a time and inserting it into its correct position in the sorted subarray.</p>

    <p>Here's the step-by-step process for performing an insertion sort on an array of numbers:</p>

    <ul>
        <li>Start with the second element (index 1) of the array and consider it as the key.</li>
        <li>Compare the key with the element(s) in the sorted subarray (i.e., all elements before the key) from right to left.</li>
        <li>If the key is smaller than the compared element, shift the compared element one position to the right.</li>
        <li>Repeat step 3 until the key is greater than or equal to the compared element or you reach the beginning of the sorted subarray.</li>
        <li>Insert the key into the correct position in the sorted subarray.</li>
        <li>Move to the next unsorted element (increment the index) and repeat steps 2-5 until all elements have been processed.</li>
    </ul>

    <p>Here's an example of how insertion sort works on an array</p>

    <ul>
        <li>Pass 1: The first element (2) is compared with 5 and moved to its correct position, resulting in [2, 5, 4, 6, 1, 3].</li>
        <li>Pass 2: The second element (4) is compared with 5, shifted to the right, and then compared with 2, resulting in [2, 4, 5, 6, 1, 3].</li>
        <li>Pass 3: The third element (6) is compared with 5 and 2, shifted to the right, and finally inserted in its correct position, resulting in [2, 4, 5, 6, 1, 3].</li>
        <li>Pass 4: The fourth element (1) is compared with all previous elements in the sorted subarray and moved to the beginning of the array, resulting in [1, 2, 4, 5, 6, 3].</li>
        <li>Pass 5: The fifth element (3) is compared with 6, 5, 4, and 2, shifted to the right, and then inserted in its correct position, resulting in [1, 2, 3, 4, 5, 6].</li>
        <li>Pass 6: The sixth element (3) is already in its correct position, so no further changes are made.</li>
    </ul>
    <p>The final sorted array is [1, 2, 3, 4, 5, 6].</p>

    <p>Insertion sort has an average and worst-case time complexity of O(n^2), where n is the number of elements in the array. However, it performs well on small input sizes and is considered efficient for nearly sorted or partially sorted arrays.</p>


    <script>
        function insertionSort(arr){
            for(let i = 1; i < arr.length; i++ ){
                let numberToInsert = arr[i];
                let j = i - 1;
                
                while(j >= 0 && arr[j] > numberToInsert){
                    arr[j+1] = arr[j];
                    j = j-1;
                }

                arr[j+1] = numberToInsert;
            }
        }

        const arr = [2, 5, 4, 6, 1, 3];
        insertionSort(arr);
        console.log(arr);

        //Big-O = O(n^2)


    </script>


    
</body>
</html>